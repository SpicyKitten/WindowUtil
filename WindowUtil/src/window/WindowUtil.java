package window;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.awt.image.MultiResolutionImage;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.function.Function;
import com.sun.jna.Memory;
import com.sun.jna.Pointer;
import com.sun.jna.platform.win32.GDI32;
import com.sun.jna.platform.win32.User32;
import com.sun.jna.platform.win32.WinDef.HBITMAP;
import com.sun.jna.platform.win32.WinDef.HDC;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.platform.win32.WinDef.RECT;
import com.sun.jna.platform.win32.WinGDI.BITMAPINFO;
import com.sun.jna.platform.win32.WinNT.HANDLE;

/**
 * Provides helpful window and screen image capture utilities
 * 
 * @author ratha
 */
public class WindowUtil
{
	/**
	 * How many characters to search in any window title
	 */
	public static final int TITLE_SEARCH_LENGTH;
	private static final Properties properties = new Properties();
	private static final User32 U32 = User32.INSTANCE;
	private static final GDI32 G32 = GDI32.INSTANCE;
	static
	{
		try (var fis = new FileInputStream("windowUtil.config"))
		{
			properties.load(fis);
			properties.computeIfPresent("title-search-length",
				(a, b) -> Math.min(1 << 16, Math.max(1,
					readProperty(cleanComments().andThen(Integer::parseInt), b))));
		}
		catch (NumberFormatException | IOException e)
		{
			e.printStackTrace();
			System.err.println(
				"Library WindowUtil Failed to load resources: Check that config settings are correct");
		}
		TITLE_SEARCH_LENGTH = (int)properties.getOrDefault("title-search-length", 256);
	}
	
	/*
	 * Cannot be instantiated
	 */
	private WindowUtil()
	{
	}
	
	/**
	 * @return A function which cleans comments from configuration file properties
	 */
	private static Function<String, String> cleanComments()
	{
		return (property) -> property.replaceAll("//.*", "");
	}
	
	/**
	 * reads a property of type R from {@code property} using conversion function
	 * {@code converter}
	 */
	private static <R> R readProperty(Function<String, R> converter, Object property)
	{
		return converter.apply(((String)property));
	}
	
	/**
	 * Tests window titles for matching to query strings
	 * 
	 * @param title
	 *            The window title to test
	 * @param query
	 *            The query string being tested against
	 * @param search
	 *            The match verifier
	 * @return true if {@code title} satisfies {@code query} according to the
	 *         {@link SearchType}, else false
	 */
	private static boolean matchesSearch(String title, String query, SearchType search)
	{
		switch (search)
		{
		case CONTAINS:
		case END:
		case EXACT:
		case EXACT_NO_CASE:
		case REGEX:
		case START:
			return search.test(title, query);
		default:
			throw new IllegalStateException(
				"Search Type provided but not implemented in WindowUtil.matchesSearch!");
		}
	}
	
	/**
	 * Enumerates all windows and computes an operation to generate output
	 * 
	 * @param op
	 * @return All non-null results generated by applying {@op} to all window
	 *         handles
	 */
	public static <T> List<T> enumerateWindows(Function<HWND, T> op)
	{
		var output = new ArrayList<T>();
		U32.EnumWindows((HWND, Pointer) ->
		{
			T result = op.apply(HWND);
			if (result != null)
				output.add(result);
			return true;
		}, (Pointer)null);
		return output;
	}
	
	/**
	 * Gets the window text associated with the given window
	 * 
	 * @param window
	 *            The window handle to the given window
	 * @param n
	 *            The maximum number of characters in the text buffer(not including
	 *            the null character)
	 * @return A trimmed string that is the title of the given window, with maximum
	 *         n characters
	 */
	public static String getTitle(HWND window, int n)
	{
		var buffer = new char[n + 1];
		U32.GetWindowText(window, buffer, n + 1);
		return new String(buffer).trim();
	}
	
	/**
	 * Find windows, with {@code query} in the first {@code TITLE_SEARCH_LENGTH}
	 * characters of their title
	 * 
	 * @param query
	 *            The query string to be searched for
	 * @param search
	 *            The query type on the title strings
	 * @return All windows matched to the query string and type
	 */
	public static List<HWND> getWindows(String query, SearchType search)
	{
		var handles = new ArrayList<HWND>();
		U32.EnumWindows((HWND, Pointer) ->
		{
			String title = getTitle(HWND, TITLE_SEARCH_LENGTH);
			if (matchesSearch(title, query, search))
			{
				handles.add(HWND);
			}
			return true;
		}, (Pointer)null);
		return handles;
	}
	
	/**
	 * Find a window with {@code query} in the first {@code TITLE_SEARCH_LENGTH}
	 * characters of its title
	 * 
	 * @param query
	 *            The query string to be searched for
	 * @param search
	 *            The query type on the title strings
	 * @return One window matched to the query string and type, or {@code null} if
	 *         there is no such window
	 */
	public static HWND getWindow(String query, SearchType search)
	{
		var handle = new HWND[1];
		U32.EnumWindows((HWND, Pointer) ->
		{
			String title = getTitle(HWND, TITLE_SEARCH_LENGTH);
			if (matchesSearch(title, query, search))
			{
				handle[0] = HWND;
				return false;
			}
			return true;
		}, (Pointer)null);
		return handle[0];
	}
	
	/**
	 * Captures an image associated with the current screen
	 * 
	 * @return The associated screen image
	 */
	public static BufferedImage capture()
	{
		Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		Rectangle region = new Rectangle(0, 0, screenSize.width, screenSize.height);
		return CaptureRobot.INSTANCE.screenshot(region);
	}
	
	/**
	 * Captures an image associated with the given window
	 * 
	 * @param window
	 *            A window handle to the given window
	 * @return The associated window image, excluding the frame
	 */
	public static BufferedImage capture(HWND window)
	{
		HDC dcWin = U32.GetDC(window);
		HDC dcMem = G32.CreateCompatibleDC(dcWin);
		Rectangle bounds = getBounds(window);
		HBITMAP bmp = G32.CreateCompatibleBitmap(dcWin, bounds.width, bounds.height);
		HANDLE hObj = G32.SelectObject(dcMem, bmp);
		G32.BitBlt(dcMem, 0, 0, bounds.width, bounds.height, dcWin, 0, 0, GDI32.SRCCOPY);
		G32.SelectObject(dcMem, hObj);
		G32.DeleteDC(dcMem);
		var bmi = new BITMAPINFO();
		bmi.bmiHeader.biWidth = bounds.width;
		bmi.bmiHeader.biHeight = -bounds.height;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biCompression = 0;
		var buffer = new Memory(bounds.width * bounds.height * 4L);
		G32.GetDIBits(dcWin, bmp, 0, bounds.height, buffer, bmi, 0);
		var image =
			new BufferedImage(bounds.width, bounds.height, BufferedImage.TYPE_INT_RGB);
		image.setRGB(0, 0, bounds.width, bounds.height,
			buffer.getIntArray(0L, bounds.width * bounds.height), 0, bounds.width);
		G32.DeleteObject(bmp);
		U32.ReleaseDC(window, dcWin);
		return image;
	}
	
	/**
	 * Captures an image associated with the current screen
	 * 
	 * @return The associated multi-resolution screen image
	 */
	public static MultiResolutionImage multiResolutionCapture()
	{
		Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		Rectangle region = new Rectangle(0, 0, screenSize.width, screenSize.height);
		return CaptureRobot.INSTANCE.multiResolutionScreenshot(region);
	}
	
	/**
	 * Gets a pixel on the screen as a Color
	 * 
	 * @param x
	 *            The x-coordinate of the pixel
	 * @param y
	 *            The y-coordinate of the pixel
	 * @return The pixel's Color
	 */
	public Color getPixel(int x, int y)
	{
		return CaptureRobot.INSTANCE.getPixel(x, y);
	}
	
	/**
	 * Captures a pixel associated with the given window
	 * 
	 * @param window
	 *            A window handle to the given window
	 * @return A pixel sampled from the associated window image, excluding the frame
	 */
	public static int getPixel(HWND window, int x, int y)
	{
		HDC dcWin = U32.GetDC(window);
		HDC dcMem = G32.CreateCompatibleDC(dcWin);
		HBITMAP bmp = G32.CreateCompatibleBitmap(dcWin, 1, 1);
		HANDLE hObj = G32.SelectObject(dcMem, bmp);
		G32.BitBlt(dcMem, 0, 0, 1, 1, dcWin, x, y, GDI32.SRCCOPY);
		G32.SelectObject(dcMem, hObj);
		G32.DeleteDC(dcMem);
		var bmi = new BITMAPINFO();
		bmi.bmiHeader.biWidth = 1;
		bmi.bmiHeader.biHeight = -1;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biCompression = 0;
		var buffer = new Memory(4L);
		G32.GetDIBits(dcWin, bmp, 0, 1, buffer, bmi, 0);
		int pixel = buffer.getInt(0L);
		G32.DeleteObject(bmp);
		U32.ReleaseDC(window, dcWin);
		return pixel;
	}
	
	/**
	 * Gets a pixel on the screen in RGB integer format
	 * 
	 * @param x
	 *            The x-coordinate of the pixel
	 * @param y
	 *            The y-coordinate of the pixel
	 * @return The pixel's RGB value
	 */
	public int getPixelRGB(int x, int y)
	{
		return CaptureRobot.INSTANCE.getPixelRGB(x, y);
	}
	
	/**
	 * Gets the bounds for a given window
	 * 
	 * @param window
	 *            The handle for the given window
	 * @return A rectangle containing window bound information
	 */
	public static Rectangle getBounds(HWND window)
	{
		var rect = new RECT();
		U32.GetClientRect(window, rect);
		return new Rectangle(rect.left, rect.top, rect.right - rect.left,
			rect.bottom - rect.top);
	}
	
}
